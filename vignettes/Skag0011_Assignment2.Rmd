---
title: "Skag0011_Assignemnt2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Skag0011_Assignemnt2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MATH5773Skag0011Assign2)
```
## Task 1,2,3
The code for the `myboot()` function is at the end.

```{r, out.width="100%", fig.width=8, fig.height = 6, fig.align='center'}
bub <- BUBBLE2
m1 <- myboot(df = bub, model = "model1", iter = 2000, alpha = 0.05)
str(m1)
m2 <- myboot(df = bub, model = "model2", iter = 2000, alpha = 0.05)
str(m2)
```


## Task 4

### a.
  $E(y) = \beta_0 + \beta_1x_{SPEED} + \beta_2x_{RATE} + \beta_3x_{PCTWT} + \beta_4x_{SPEED}x_{RATE} + \beta_5x_{SPEED}x_{PCTWT}+ \beta_6x_{RATE}x_{PCTWT}$

### b.
  $\beta_3 + \beta_5*1000 + \beta_6*50$
 
### c.
  $\beta_3 + \beta_5*1000 + \beta_6*150$
 
### d. 
```{r}
v <- Intro2MLR::myreadxl("C:/Users/tyler/Documents/Grad School/MATH 5773/Data/Excel/")
ylm <- lm(FORCE ~ SPEED + RATE + PCTWT + (SPEED * RATE) + (SPEED * PCTWT) + (RATE * PCTWT), data = v$DRILLMETAL)
summary(ylm)
```
 
 
### e.

## Task 5
```{r}
ylm <- lm(`Man-HRs` ~ Capacity + Pressure + Capacity*Pressure, data = v$BOILERS )
summary(ylm)


(-1.529 + .003439*750)
```

### a.
 Looking at the summary output we can see that the $F$-statistic

### b.
  Again from the summary output we see that the relationship between Capacity and Pressure contributes a positive slope of $\beta_3 = 3.439$. We see that the $p$-value for a one-tail test is $0.032662/2 = 0.0163$ with $\alpha = 0.05$. There is significant evidence supporting that the slope is nonzero (we reject the null).
 
### c.


## Task 6

### a.

### b.

## The `myboot()` Function
```{r}
myboot <- function(df, model = "model1", iter = 1, alpha = 0.05){

  n = 18
  k = 2

  #Switch Statement to pick model
  mod_index <- switch (model,
                       model1 = 4, #column 4 is Diameter

                       model2 = 5  #column 5 is Diensity
  )

  ############## MAKING MATRICIES ##############
  X <- matrix(c(rep(1,n), df$MassFlux, df$HeatFlux), nrow = n, ncol = (k+1))
  Y <- as.matrix(df[mod_index])

  beta <- solve(t(X) %*% X) %*% (t(X) %*% Y)
  rownames(beta) <- c("(Intercept)", "MassFlux", "HeatFlux")

  ############## CALCULATING STATISTICAL VALUES ##############
  SSE <- ( t(Y) %*% Y ) - ( t(beta) %*% t(X) %*% Y)
  s.squared <- SSE/(ln - (k+1)) #SSE / df
  C <- solve(t(X) %*% X)

  C_ii <- c() #C_ii is used to create confidence intervals
  for(i in 1:length(beta)){
    C_ii = c(C_ii, C[i,i])
  }

  ############## CREATING CI ##############
  Lower <- beta - qt(1-alpha/2, n-(k+1)) * sqrt(c(s.squared) * C_ii)
  Upper <- beta + qt(1-alpha/2, n-(k+1)) * sqrt(c(s.squared) * C_ii)

  CI <- matrix(c(Lower, Upper), nrow = k+1, ncol = 2)
  rownames(CI) <- c("(Intercept)", "MassFlux", "HeatFlux")
  colnames(CI) <- c(paste0(100*alpha/2, '%'), paste0(100*(1-alpha/2), '%'))



  ############## SAMPLING SECTION ##############
  hbetas <- matrix(NA, nrow = iter, ncol = 3)
  for(i in 1:iter){
    index <- sample(1:18, 18, replace = TRUE) #random sample of 18 data pts

    X_samp <- matrix(c(rep(1,n), df[index,]$MassFlux, df[index,]$HeatFlux),
                     nrow = n, ncol = (k+1))
    Y_samp <- as.matrix(df[index,][mod_index])

    hbetas[i,] <- solve(t(X_samp) %*% X_samp) %*% (t(X_samp) %*% Y_samp)
  }

  ############## PLOTTING AND RETURN ##############
  layout(matrix(1:3, nrow = 1,ncol = 3))
  hist(hbetas[,1],
       xlab = expression(widehat(beta)[0]),
       main = paste0("Histogram of intercept estimate\n",
                     "Point estimate: ", round(beta[1],8)))

  hist(hbetas[,2],
       xlab = expression(widehat(beta)[1]),
       main = paste0("Histogram of slope 1 estimate\n",
                     "Point estimate: ", round(beta[2],8)))

  hist(hbetas[,3],
       xlab = expression(widehat(beta)[2]),
       main = paste0("Histogram of slope 2 estimate\n",
                     "Point estimate: ", round(beta[3],8)))

  my_list <- list(beta_iters = as.data.frame(hbetas), CI_beta = CI,
                  beta_pts = beta, iter = iter, model = model, alpha = alpha)
  return(invisible(my_list))
}
```
